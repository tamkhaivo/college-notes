# Computer Organization

Dr. Posnett - Math Degree

Textbook
Digital Design and Computer Architecture ARM Edition

Java
Powers of 2 to 16
1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,
2048, 4096, 8192, 16384, 32768, 65536

## Grading

1. Pop Quizzes - 5-10%
2. Quizzes - 30-35%
3. Final Exam - 30-35%
4. Projects/HW - 30-35%

A = 100-84.45
B = 84.44-69.45
C = 69.44-54.45
D = 49.45-55
F = 50-0

## Important - Most Time

1. CPU (DESIGN AND BUILD CPU)

- conventional (positivde to negative)
- Combinations -> Binary States
- All circuits are connected to volts & ground
  -- vcc (voltage) = cdd (drain)
  -- inverter = NOT can be added to the regular circuits to make them NAND, NOR, NXOR
  -- cononical ordering = truth tables
  -- XOR = AB' + A'B

2. RAM
3. GPU
4. Tensor Processing Unit (Specialized Math Chip)

## Data Representation

## Digital Design

### Combinational Design (No Memory States)

1. Capture

- Truth table or equation whichever describes **desired behavior**

2. Convert

- Truth Table instead of equations -- create an equation for each output then SIMPLIFY KMAPS --> Column Simplfiction
- Minimze number of chips - Minimize number of gates - CMOS 4000 - Dual inline packages (DIP 14)

3. Implement

- For each output create a circuit corresponding to the output equations

Output in binary, on 2 outputs y and z, the number of 1s on 3 binary inputs a,b,c

- Adding 3 single binary numbers --> Voting System
- A'B'C + A'C'B + B'C'A + ABC (Midterm) = y
- ABC' + AC'B + BCA' + ABC (Midterm) = z

{ABC} == Term
A, B, C == Factors

==> Max numbers of inverters I need? (len of input)
==> Max Number of AND gates = Count of 1s in output on truth table (Unless shared & No timing issues aka glitches)

#### Example

F = A'BC + AB'C + ABC' + ABC + ABC + ABC
==> BC(A' + A) + AC(B' + B) + AB(C' + C)
==> BC + AC + AB

| Expression                   | Simplification | Name         |
| ---------------------------- | -------------- | ------------ |
| B & 1 = B                    | B              | Identity     |
| B + 0 = B                    | B              | Identity     |
| B & 0 = 0                    | 0              | Null         |
| B + 1 = 1                    | 1              | Null         |
| B & B = B                    | B              | Idempotency  |
| B + B = B                    | B              | Idempotency  |
| B'' = B                      | B              | Involution   |
| B & B' = 0                   | 0              | Complements  |
| B + B' = 1                   | 1              | Complements  |
| B & C = C & B                | -              | Communitive  |
| B + C = C + B                | -              | Communitive  |
| A(B & C) = (A & B)C          | -              | Associative  |
| A +(B + C) = (A + B) + C     | -              | Associative  |
| A(B + C) = (AB + AC)         | -              | Distributive |
| A + (BC) = (A + B) & (A + C) | -              | Distributive |
| A(A + C) = AA + AC           | A              | Covering     |
| A +(A + C) = A+A + A+C       | A              | Covering     |

### KMAPS

Kmap - you are garunteed to have minimum circuit (and or and not gates)

- minimize
- Square groups - look at the bits that do not change and use that as an indicator for similifiatoin

- Boolean expressions can be minimized by combining terms
  AB 00 01 11 10 <-- Greay Code 1 bit change at at time
  **\*\***\_\_**\*\***
  C 0 | 0 1 0 0
  1 | 0 1 1 0

- Every 1 must be circled at least once
- Each Circle span a power of 2
- Each circle must be as large as possible
-

1. Complement - Bar over it
2. Literal - Complement
3. Impl

Kilobyte - 1_000 = 10^3
Megabyte - 1_000_000 = 10^6
Gigabyte = 1_000_000_000 = 10^9
Terrabyte= 1_000_000_000_000 = 10^12
Petabyte = 1_000_000_000_000_000 = 10^15

**Violate POLs/a**
Priciple of lease surprise or astonishment

| X1  | X2  | X3  | X4  | n   | a   | b   | c   | d   | e   | f   | g   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 0   |
| 0   | 0   | 0   | 1   | 1   | 0   | 1   | 1   | 0   | 0   | 0   | 0   |
| 0   | 0   | 1   | 0   | 2   | 1   | 1   | 0   | 1   | 1   | 0   | 1   |
| 0   | 0   | 1   | 1   | 3   | 1   | 1   | 1   | 1   | 0   | 0   | 1   |
| 0   | 1   | 0   | 0   | 4   | 0   | 1   | 1   | 0   | 0   | 1   | 1   |
| 0   | 1   | 0   | 1   | 5   | 1   | 0   | 1   | 1   | 0   | 1   | 1   |
| 0   | 1   | 1   | 0   | 6   | 1   | 0   | 1   | 1   | 1   | 1   | 1   |
| 0   | 1   | 1   | 1   | 7   | 1   | 1   | 1   | 0   | 0   | 0   | 0   |
| 1   | 0   | 0   | 0   | 8   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 1   | 0   | 0   | 1   | 9   | 1   | 1   | 1   | 1   | 0   | 1   | 1   |
| 1   | 0   | 1   | 0   | A   | 1   | 0   | 1   | 1   | 1   | 1   | 1   |
| 1   | 0   | 1   | 1   | B   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
| 1   | 1   | 0   | 0   | C   | 1   | 0   | 0   | 1   | 1   | 1   | 0   |
| 1   | 1   | 0   | 1   | D   | 0   | 1   | 1   | 1   | 0   | 0   | 1   |
| 1   | 1   | 1   | 0   | E   | 1   | 0   | 0   | 1   | 1   | 1   | 1   |
| 1   | 1   | 1   | 1   | F   | 1   | 0   | 0   | 0   | 1   | 1   | 1   |

Product of Sums == more 1s than 0s
Sum of Products == more 0s than 1s

Both are logically equivant
e = !X1!X2!X3!X4 + !X1!X2X3!X4 + !X1X2X3!X4 + X1!X2!X3!X4

| X3X4 \ X1X2 | 00  | 01  | 11  | 10  |
| ----------- | --- | --- | --- | --- |
| 00          | 1A  | 0   | X   | 1A  |
| 01          | 0   | 0   | X   | 0   |
| 11          | 0   | 0   | X   | X   |
| 10          | 1AB | 1B  | XB  | XAB |

Priortize ROW and COLUMN Elimination

From Group A - X3'X1' + X2X0'
From Group B -

Logicsim Evolution
https://github.com/logisim-evolution/logisim-evolution

Aseembly Language buildes out from the Hardware
Arithmatic Logic Unit - ALU

- And
- Or
- Not
- Xor
- Add

Takes in A, B, OP, and Result

2^7 =128

MuX - Miultiplexer - Which Multiple operation gets to go through.
Y = AS' + BS

Y = AS'S' + B'S'S + C'SS' + DSS

The reason why we are learning this
xnor = equality or and

#### Decoder

- Mux with inputs taken away that simply says that 1 output must be ONE
- Decoding binary input into decimal output
- One Hot encoding = one output is high at once

### Logisim 3.9.0

- Clock SPeed 1hz is 1 cycle per second
- Auto-Tick Enabled - Clock is pulsing
- Step - 256hz max
- DIP Switch = Dual In P

Bulding an ALU

- Core of how a cpu computes
- SKIP ENCODER - DECODER
- Priority Decoder - IO

Modular Design

- Understanding how to build it in logisim
- Wont be shocked by

- NAND and NOR gates are universially used

Combinations of Gates for 1 input

1. Bottom (Ground)
2. Buffer
3. Inverter
4. Vcc

Combinations of Gates for 2 inputs
16 gates
Implication is almost universal - with TOP and Bottom

| OPCable | Operation | RTL   |
| ------- | --------- | ----- |
| OO      | Add       | A + B |
| 01      | SUB       | A - B |
| 10      | NOT       | A'    |
| 11      | AND       | A & B |

Substraction is Easier?

High Z = is closed circuit
TriState Buffers = Wire Or

Ripple Carry Adder too slow. How to speed up?
Replace the carry to a constant time
`Co = Go + Po Cin
 C1 = G1 + Po Co
  TTL --> Transister Transfer Logic
  RTL --> Resisters Tranfer Logic
`

Arithmetic Bit Shifter Left >>>
Connected with wires - Simpily but if chaining these there will be a propogation delay
1011 --> 0101

Bit Shifter >>
1011 --> 0101

SHAMPT - SHIFT amout

R 3-0 --> [ ]

Astable CLock (74HC14) - (7414) -
f = K /Rc = Frequency = K / Resistance \* Ferads

Non-overlapping Pattern for 101 -- Moore Machine

| Q1  | Q0  | Input | CurrentState | NextState | D1  | D0  |
| --- | --- | ----- | ------------ | --------- | --- | --- |
| 0   | 0   | 0     | S0           | S0        | 0   | 0   |
| 0   | 0   | 1     | S0           | S1        | 0   | 1   |
| 0   | 1   | 0     | S1           | S2        | 1   | 0   |
| 0   | 1   | 1     | S1           | S1        | 0   | 1   |
| 1   | 0   | 0     | S2           | S0        | 0   | 0   |
| 1   | 0   | 1     | S2           | S3        | 1   | 1   |
| 1   | 1   | 0     | S3           | S0        | 0   | 0   |
| 1   | 1   | 1     | S3           | S1        | 0   | 1   |

D1 = Q1'Q0I' + Q1Q0'I
D0 = I

`
` 1 0 1
-> s0 ---> s1 ---> s2 ---> s3

`

overlapping Pattern for 101 - Mealy Recognizer - UNSYNCRONIZED

| Q1  | Q0  | Input | CurrentState | NextState | D1  | D0  |
| --- | --- | ----- | ------------ | --------- | --- | --- | -------------------------------------------------------------- |
| 0   | 0   | 0     | S0           | S0        | 0   | 0   |
| 0   | 0   | 1     | S0           | S1        | 0   | 1   | // D0 = I                                                      |
| 0   | 1   | 0     | S1           | S2        | 1   | 0   | // at best we are going to have D1 = Q1'Q0I' or D0 = Q0I'      |
| 0   | 1   | 1     | S1           | S0        | 0   | 1   |
| 1   | 0   | 0     | S2           | S0        | 0   | 0   |
| 1   | 0   | 1     | S2           | S1        | 1   | 1   |
| 1   | 1   | 0     | S3           | X         | X   | X   | // Dont care will never happen? Try and just reset the machine |
| 1   | 1   | 1     | S3           | X         | X   | X   |

Synronize the output by another flipflop that is clocked together

- Removing Glitches
- Removing Delays
- Simplier Circuit
- Unsyncronized

### Sequential Design

- setup time constraint
- hold time constraint
- Propegation delay
- Contamindation delay

#### Contamination Delay

- Time for Output doesnt change between Input Changes
- Current State starts to change
- Time after clock edge that might be unstable

1. For Sequential Circuit such as 2 D-flip flops connected in series
2. The contamination delay of the first flip flip must be factored in to avoid violating the hold-time constraint of the second flip-flop receiving the output from the first flip flop
3. Here the contaminsation delay is the amount of time needed for a change in the flipflip clock input to result in the initial change at the flipflop output q
4. If there is insufficicent delay from the output of the first flip-flop to the input of the second, the input may change before the hold has passed.
5. Because the second flopflop is still unstable its data would then be contaminsated

##### Dynamic Displine

- Synchronous sequential circuits inputs must be stable during aperture (setup and hold) time around clock edge
- Specifically inputs must be stable
  -- at least t(setup) before the clockedge
  -- at least until t(hold) after the clockedge
- The delay between registers has a minimium and maxium delay dependent on the delays of the circuit elements

##### Setup time constraing

- Depends on the _Maximum_ delay from register R1 through combinational logic to R2
- The input to register R2 must be stable at least t(setup) before clock edge
- T(c) >= Tpcq + Tpd + Tsetup
- Tpd <= Tc - (Tpcq + Tsetup)
- (Tpcq + Tsetup) is called a sequencing overhead

== R1 --> Q1 --> CL --> D2 --> R2

#### Propagation Delay

- Output pernimately changed
- time after clock edge that the output Q is guaranteed to be stable ( time to stop changing )

#### Setup Time

- Time before clock edge data must be stable
- For us to keep subject still

#### Hold Time

- GIVEN in Data sheet
- Time after clock edge must be stable
- For read so that input isnt blurry

#### Hold time constraint

- Shortest Delay from R1 through combinational Circuit to R2
- T(hold) < T(ccq) + T(cd)
- T(cd) > T(hold) - T(ccq)
- Think about the propogational delay
- make sure that nothing change between the hold time and the clock edge

Ex Timing Analysis

- T(ccq) = 30ps
- T(pcq) = 50ps
- T(setup) = 60ps
- T(hold) = 70ps
- T(pd)/per gate = 35ps
- T(cd)/per gate = 25ps

#### Clock Skew

- The clock doesnt arrive at all registers at the same time
- Skew Difference between 2 clock edges
- perform worst case analysis to guarantee dynamic discipline is not violated for any register - many registers in a system
- T(clock) >= Tccq + Tcd + Tsetup + tskew

#### Apature Time

- GIVEN in Data sheet
- Time around clock edge data must be stable
- Setup Time + Hold Time = Apeture Time

## Building Blocks of CPU Design

## Memory

## I/O
